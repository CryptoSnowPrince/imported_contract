archetype cake
// archetype cake(factory: address, token: address, tokenBalBefore: nat, tokenBalAfter: nat, delta: int)

// function onlyFactoryOwner(): bool {
//     var factoryOwner: address ?= call_view<address>(factory, "getOwner", Unit) : "VIEW_OWNER_ERR";
//     do_require(caller = factoryOwner, "ONLY_FACTORY_OWNER_ERR");
//     return true
// }

// entry setCurBalBefore(bal: nat) {
//     tokenBalBefore := bal
// }

// entry setCurBalAfter(bal: nat) {
//     tokenBalAfter := bal
// }

// entry action1(amount: nat) {
//     transfer 0tz to token call getBalance<address * contract<nat>>((self_address, self.setCurBalBefore));
//     transfer 0tz to token call %transfer<address * address * nat>((self_address, caller, amount));
//     transfer 0tz to token call getBalance<address * contract<nat>>((self_address, self.setCurBalAfter));
//     delta := tokenBalBefore - tokenBalAfter
// }

// entry action2(amount: nat) {
//     effect {
//         transfer 0tz to entry self.setCurBalBefore(amount);
//         const val = tokenBalBefore + 2;
//         transfer 0tz to entry self.setCurBalAfter(val)
//     }
// }

// function transform(param: Param, val: int): Param {
//     // TODO
//     return param
// }

// function call_trans(param: option<Param>, val: bool, val11: bool) : Param * Param {
//     const param_1 ?= param : "ERR";
//     if val11 then begin
//         if val then begin
//             return ((transform(param_1, 1), param_1))
//         end else begin
//             return ((transform(param_1, 0), param_1))
//         end
//     end;

//     return ((param_1, param_1))
// }

record Param {
    val1: int;
    val2: nat;
}

variable params: list<Param> = [{1;1}]

asset infosss identified by id to big_map {
    id: nat;
    valinfosss: Param;
}

entry setList(index: nat, val11: int, val22: nat) {
    var val ?= nth(params, index) : "ERR";
    val.val1 := val11;
    val.val2 := val22
}

entry setAsset(index: nat, val11: int, val22: nat) {
    var val_param: Param = {val11; val22};
    infosss[index].valinfosss := val_param
}

entry setAsset1(index: nat, val11: int, val22: nat) {
    var val_param: Param = {val11; val22};
    infosss.add_update(index, {
        valinfosss := val_param
    })
}

view getMax(index: nat): nat {
    var val = 1 <<| index;
    return val
}

function hello(index: nat) : nat {
    return index
}


view int_to_nat_test(index: int) : nat {
    const val ?= int_to_nat(index) : "ERR";
    return val
}

view abs_test(index: int) : nat {
    return abs(index)
}
