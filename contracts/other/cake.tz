# (Pair factory token tokenBalBefore tokenBalAfter 0)
{
  storage (pair (address %factory) (address %token) (nat %tokenBalBefore) (nat %tokenBalAfter) (int %delta));
  parameter (or (or (nat %setCurBalBefore) (nat %setCurBalAfter)) (nat %action1));
  code { LAMBDA
           address
           bool
           { PUSH unit Unit;
             DUP 2;
             PUSH unit Unit;
             VIEW "getOwner" address;
             IF_NONE
               { PUSH string "VIEW_OWNER_ERR";
                 FAILWITH }
               {  };
             DUP;
             SENDER;
             COMPARE;
             EQ;
             NOT;
             IF
               { PUSH string "ONLY_FACTORY_OWNER_ERR";
                 FAILWITH }
               {  };
             PUSH bool True;
             DIP { DIG 1; DROP };
             DUG 1;
             DROP;
             DUG 1;
             DROP };
         NIL operation;
         DIG 2;
         UNPAIR;
         DIP { UNPAIR 5 };
         IF_LEFT
           { IF_LEFT
               { DUP;
                 DIP { DIG 3; DROP };
                 DUG 3;
                 DROP;
                 PAIR 5;
                 DIG 1;
                 PAIR }
               { DUP;
                 DIP { DIG 4; DROP };
                 DUG 4;
                 DROP;
                 PAIR 5;
                 DIG 1;
                 PAIR } }
           { NIL operation;
             NIL operation;
             DUP 9;
             ITER { CONS };
             DUP 5;
             CONTRACT %getBalance (pair address (contract nat));
             IF_NONE
               { PUSH string "getBalance";
                 PUSH string "ENTRY_NOT_FOUND";
                 PAIR;
                 FAILWITH }
               {  };
             PUSH mutez 0;
             SELF_ADDRESS;
             CONTRACT %setCurBalBefore nat;
             IF_NONE
               { PUSH string "setCurBalBefore";
                 PUSH string "ENTRY_NOT_FOUND";
                 PAIR;
                 FAILWITH }
               {  };
             SELF_ADDRESS;
             PAIR;
             TRANSFER_TOKENS;
             CONS;
             ITER { CONS };
             DIP { DIG 6; DROP };
             DUG 6;
             NIL operation;
             NIL operation;
             DUP 9;
             ITER { CONS };
             DUP 5;
             CONTRACT %transfer (pair address address nat);
             IF_NONE
               { PUSH string "transfer";
                 PUSH string "ENTRY_NOT_FOUND";
                 PAIR;
                 FAILWITH }
               {  };
             PUSH mutez 0;
             DUP 5;
             SENDER;
             PAIR;
             SELF_ADDRESS;
             PAIR;
             TRANSFER_TOKENS;
             CONS;
             ITER { CONS };
             DIP { DIG 6; DROP };
             DUG 6;
             NIL operation;
             NIL operation;
             DUP 9;
             ITER { CONS };
             DUP 5;
             CONTRACT %getBalance (pair address (contract nat));
             IF_NONE
               { PUSH string "getBalance";
                 PUSH string "ENTRY_NOT_FOUND";
                 PAIR;
                 FAILWITH }
               {  };
             PUSH mutez 0;
             SELF_ADDRESS;
             CONTRACT %setCurBalAfter nat;
             IF_NONE
               { PUSH string "setCurBalAfter";
                 PUSH string "ENTRY_NOT_FOUND";
                 PAIR;
                 FAILWITH }
               {  };
             SELF_ADDRESS;
             PAIR;
             TRANSFER_TOKENS;
             CONS;
             ITER { CONS };
             DIP { DIG 6; DROP };
             DUG 6;
             DUP 5;
             INT;
             DUP 5;
             INT;
             SUB;
             DIP { DIG 5; DROP };
             DUG 5;
             DROP;
             PAIR 5;
             DIG 1;
             PAIR };
         DIP { DROP } };
}

